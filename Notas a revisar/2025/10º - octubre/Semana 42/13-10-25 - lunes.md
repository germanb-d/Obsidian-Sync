---
journal: Calendario
Diario-Fecha: 2025-10-13
---

# Conceptos (ACID)

Objetivos que debe cumplir una BD para ser eficiente y correcta.

## Transacción

Una unidad logica de trabajo.

### Atomicidad

Todas las operaciones de la transacción se ejecutan o no lo hacen ninguna de ellas.

**Ejemplo**: Si se va a realizar un pago y justo sucede algo, no puede quedar el pago a medias, o se pagó o no se pagó.

**Ejemplo**: El realizar una tabla de una factura, aunque conlleva muchos pasos el agregar todas las filas de las facturas, esta factura se debe tomar como una única transaccion. O se hace completa o no se hace.

### Consistencia

> la ejecución aislada de la transacción conserva la consistencia de la BD

Dice aislada porque se toma como una situación mono usuario, esto no es igual al Aislamiento.

### Aislamiento (isolation)

> Cada transacción ignora el resto de las transacciones que se ejecutan concurrentemente en el sistema, actúa c/u como única.

### Durabilidad

> una transacción terminada con éxito realiza cambios permanentes en la BD, incluso si hay fallos en el sistema.

Toda transaccion terminada debe ser permanente aun cuando la base de datos se caiga 1 segundo despues.

# Transacciones

![[13-10-25 - lunes-1760391368495.webp]]

Transaccion Completa:

- Read A
- A = A-100.000
- Read B
- B= B+100.000
- Commit

**Activa**: Leer saldo de A
**Fallada**: Fallo de concurrencia, fallo en sintaxis, fallo en datos, etc.

**Activa**: Leer saldo de A
**Parcialmente cometida / commit**: es cuando aún no llega al commit, después de ejecutarse la última instrucción.
**Fallada**: Falla al hacer el commit.

**Abortada**: Después de haber retrocedido la transacción y restablecido la BD al estado anterior al comienzo de la transacción.

**Cometida**: tras completarse con éxito. En sí es cuando se realiza el commit, cuando es finalmente grabada en la bitacora EN DISCO, a mi no me interesa si está grabada o no en disco.

## Transacción Abortada

## Modelo De Transaccion

![[13-10-25 - lunes-1760392272226.webp]]

T: Memoria de la transacción (la memoria del programa)- Memoria de la BD - Disco

Al t realizar un READ primero pide el dato a la memoria de la BD y si esta no la tiene la busca en disco. (nunca olvidarse que entre la memoria de la BD y el disco se pasa por el SO)

### Uso De Transacciones

- **En sistemas monousuarios**: Más raro a menos que estemos practicando como nuestro caso, acá no puede haber dos personas accediendo al mismo dato.
- **En sistemas concurrentes**: Una BD en un solo servidor con mucha gente trabajando con esta a la vez.
- **En sistemas distribuidos**: Una sola BD lógica, pero está instalado en varios servidos conectados por una misma red. (no la vemos en esta materia).

# Fallos

## Primer Clasificacion

### Sin Pérdida De Información

Si yo solo leo para imprimir en pantalla y falla, no hay consecuencias.

### Con Pérdida De Información

#### Fallo En la Transacción

**Lógicos**: interno a la transacción. No una falla de sintaxis, sino una falla de lógica como por ejemplo buscar por nombre y apellido en vez de por una clave, puede que funcione mucho tiempo, pero a la larga va a fallar.

**Del sistema**: bloqueos (bloqueos son la forma de manejar las concurrencias). Esto aborta la transaccion fallida y retorna los datos correctos.

#### Caída Del Sistema: (hardware, Software (SO, DBMS)

#### Fallo De Disco: Es Necesario Tener Backups.

## Algoritmos De Tratamiento De Fallos

- Acciones llevadas a cabo durante el procesamiento normal de la transacción que permiten la recuperación ante fallos
- Acciones llevadas a cabo después de ocurrir el fallo para restablecer el contenido de la BD a un estado que asegure ACID.

¿Como sabe la BD que tiene que volver a recuperar los datos? Al realizar una shatdown (bajar la BD) esto baja todo lo de memoria a disco y al realizar esto guarda una flag de que esta BD bajo normal. A la BD levantarse nuevamente revisa la flag, si la BD se levanta luego de un mantenimiento comun la flag estara normal, pero si se dio por un fallo inesperado esta vera el flag y determinara que tiene que recuperar los datos.

## Estructura De Almacenamiento

### Almacenamiento Volátil

### Almacenamiento no Volátil

### Almacenamiento Estable

Un ejemplo sería el uso de un disco espejado.

Otro ejemplo:

Un Raid 5 de por ejemplo 3 discos. Estos 3 discos guarda cada uno informacion particular y tiene un espacio separado para almacenar informacion comun entre los 3 discos, esto poara que en caso de que un disco se rompa los otros dos puedan manejar los datos que este disco roto ya no posee. Esto hara las consultas mas lentas pero la BD seguira funcionando, dandome tiempo para remplazar el disco duro.

## Recuperación En Caso De Fallo

- Re-ejecutar: no sirve
- No Re-ejecutar: no sirve
- Problema: modificar la BD sin seguridad que la transacción se va a cometer.
- Solución: indicar las modificaciones antes de hacerlas efectivas - > permite recuperar

### Métodos De Recuperación

#### Basado En Bitácora (log)

Registro histórico: secuencia de actividades realizadas sobre la BD. (A poder ser en otra memoria fisica)

![[13-10-25 - lunes-1760394449517.webp]]

```
Contenido de la bitácora
 <T iniciada> (cuando inicia)
<T, E, Va, Vn> (para cada dato que modifica)
- Identificador de la transacción
- Identificador del elemento de datos (que dato es)
- Valor anterior
- Valor nuevo
<T Commit>
<T Abort> No se dan ambos: Se da el commit o se da el Abort

```

##### Caso De Oracle

Usualmente tengo varias bitacoras, dependiendo cuantas datos se modifiquen por minuto. Por ejemplo: si tenemos 3 copias de una bisca bitacoras.

Yo tengo B 1, B 2 y B 3

B 1 esta formada por 5 archivos, cada vez que termina uno luo guarda en un backup hasta llegar a los 5 archivos, llegado este momento pisa el primer archivo. Usualmente el backup siempre debe tardar menos de lo que tarda en procesarce los siguientes 4 archivos antes de que llegue a querer pisar el archivo que se esta backepeando, si esto no se hace el proceso de pausa hasta que se realice el back up.

Yo tengo un backup por cada bitacora.

B 1 = B 2 = B 3

Backup 1 = Backup 2 = Backup 3

Cuando se guarda la transaccion en la bitacora en cuando se hace el commit

##### Que Se Hace Antes De Que Se Caiga la BD?

No se hace nada porque no se cuando sucede, lo unico que estoy seguro es que puedo recuperar como estaba la BD con la bitacora #Parcial

##### Dos Técnicas De Bitácora

**Modificación diferida de la BD**: Retener la transacción en memoria hasta que no se realiza la bitacora completa (llega al commit). Esto hace la BD más lenta, pero te evita el volver atras en caso de fallos al igual que te evita almacenar los datos temporales.
- O se graba toda la transaccion con el commit o no se graba nada.

**Modificación inmediata de la BD**: Yo PERMITO `[!!info|No lo hace siempre, solo esta habilitada a hacerlo|224, 142, 0]` que la BD pueda ir al disco cuando quiera para grabar datos (hacer el OUTPUT). El paso a paso sigue estando en la bitacora igualmente, aunque no va a esperar hasta llegar al commit.

Ante un fallo, y luego de recuperarse:

`REDO` ( Ti ), para todo Ti que tenga un Start y un Commit en la Bitácora.

- (sobrescribe los datos por los de la bitacora, porque yo no se si el disco esta escrito luego del commit o no, entonces en vez de comparar que seria mas lento, directamente sobrescribo los valores)
- Esto es lo que siempre se realiza en BD que utiliza modificaciones diferidas, porque jamas graba en la bitacora si no tiene un commit.
`UNDO` ( Ti ), para todo Ti que tenga un Start y no un Commit (tenga abort o no)
- Sobrescribe por los datos viejos. (o sea dejo grabado los datos que tenía al iniciar la transacción )

#### Buffers De Bitácora

![[13-10-25 - lunes-1760397623257.webp]]

Se graba primero la bitacora porque este me guia para recuperarme en caso de una caida.

Tan solo se revisa despues de una caida la bitacora que se encuentra grabada en el disco #Parcial

### Puntos De Verificación

![[13-10-25 - lunes-1760397782291.webp]]

El checkpoint marca cuando todas las transacciones en volatil terminaron y esta todo OK en disco. (se realiza una pausa para bajar todo a disco y hacer el checkpoint)

 Esto significa que, en caso de fallo, solo necesitamos recuperar las transacciones que comenzaron después del último checkpoint.

 Cuando los pone? :

- Con la memoria llena y debe bajar a disco.
- Cada X tiempo. (segundos).
Usualmente se determina segun el maximo tiempo que quiero que este para recuperarse en caso de una caida. #Parcial

### Doble Paginacion ( no Se Toma )

Me ahorra el tiempo de escribir en log y es mas rapida de recuperar.

![[13-10-25 - lunes-1760398297733.webp]]
